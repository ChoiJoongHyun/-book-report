4장. 스코프
-----------

### 스코프를 의식하고 있는가?

> 평범한 주제이지만 프로그래밍의 모든 곳에서 스코프는 존재하며, 이것은 또한 유지보수성에 커다란 영향을 준다.

### 스코프란 무엇인가?

> 스코프는 변수나 메소드, 클래스 등이 보이는 범위다. '보인다' 라는 것은 그것들이 '프로그램에서 사용될 수 있다' 라는 것이다. '사용할 수 있다' 라는 것은 바꾸어 말하면 그것들에 '의존한다'라는 의미도 있다. 코드를 단지 한 곳만 고쳐 쓰고 싶은데 수십 곳을 수정하여야 한다면 의존성이 크다 라고 할 수 있다.
>
> -	스코프 = 보이는 범위 = 사용할 수 있는 범위 = 의존하는 범위 = 의존성에 영향을 주는 범위
> -	스코프가 작다 = 의존성이 작다
> -	스코프가 크다 = 의존성이 크다

### 스코프를 작게 해서 기억해 둘 것을 줄이자!

> 프로그래밍은 본질적으로 복잡한 것이다. 복잡함에 대한 대책으로 문제 영역을 가능한 한 작고 이해 가능한 상태로 취급될 수 있도록 하는 것이 중요하다.
>
> 스코프를 의식적으로 작게 함으로써 우리 프로그래머들이 기억해 두지 않으면 안되는 것, 주의하지 않으면 안 되는 것에 대한 범위도 작아져 이해를 쉽게 할 수 있게 된다. 이것이 스코프를 작게 하는 일의 본질이라고 말할 수 있다.

### 변수의 스코프

###### - 로컬 변수의 스코프

> 로컬 변수란 메소드의 내부 등에서 선언된 일시적인 변수다. 어느 변수의 의존을 최소화하거나 프로그램의 변경을 쉽게 시행하게 하기 위해서 로컬 변수의 스코프는 가능한 한 작게 하는 것이 대원칙이다.
>
> -	변수는 사용하기 직전에 선언한다.
> -	메소드로 추출한다.
> 	-	어느 정도 정리가 된 처리를 별도의 메소드로 추출하는 리팩토링을 하면, 새로운 메소드의 범위에서 변수의 스코프가 생긴다.
> -	반복자에서 사용하는 일시 변수의 스코프를 루프 내로 한정한다.
> -	대입되지 않는 변수에는 final 을 붙인다.
> 	-	특히 긴 스코프의 변수나 메소드의 인수에서 사용하면 효과적이다.

###### - 필드 변수

> 필드 변수는 인스턴스(객체)별로 보관/유지 되는 번수를 말한다.
>
> ```java
> public class Foo {
>   private String bar; //필드변수
> }
> ```
>
> -	private
> 	-	객체 내에서만 접건 가능
> -	package private
> 	-	동일 패키지로부터만 접근 가능
> -	protected
> 	-	동일 패키지와 하위 클래스의 객체로부터만 접근 가능
> -	public
> 	-	다른 객체로부터 접근 가능

###### - 클래스 변수

> 클래스 변수는 클래스가 보관/유지하는 변수이다.
>
> ```java
> public class Foo {
>   private static String bar; //클래스 변수
> }
> ```
>
> -	private
> 	-	객체 내에서만 접건 가능
> -	package private
> 	-	동일 패키지로부터만 접근 가능
> -	protected
> 	-	동일 패키지와 하위 클래스의 객체로부터만 접근 가능
> -	public
> 	-	다른 객체로부터 접근 가능
>
> 클래스 변수에 final 을 붙이면 외부로부터 값을 변경할 수 없으므로 public 으로 공개해도 비교적 안전하다. 또한 불변객체를 사용하여 안전하게 공개한다. ex) Arrays.asList("foo", "bar")
>
> 외부로부터 변경이 불가능한 객체럴 이뮤터블(immutable)한 객체라고 한다. 반대로 변경 가능한 객체를 뮤터블(mutable) 한 객체라고 한다.

### 메소드의 스코프

###### - 인스턴스 메소드

> 인스턴스 메소드는 인스턴스(객체)에 결부되어 호출할 수 있는 메소드를 말한다.

###### - 클래스 메소드

> 클래스 메소드 (static 메소드) 는 클래스에 속해 있는 메소드이다.

###### - 메소드 파라미터의 정보량

> 메소드의 파라미터로 건네주는 정보량을 어느 정도로 해야 하는가 또한 의존성의 측면에서 보면 중요하다.
>
> ```java
> // 1. 인수가 사원 ID 인 경우
> public Employee getEmployee(Integer empId) {
>   return empDao.findById(empId);
> }
> ```
>
> ```java
> //2. 인수가 사원 오브젝인 경우
> public Employee getEmployee(Employee emp) {
>   return empDao.findById(emp.getId());
> }
> ```
>
> 1번인 쪽이 파라미터의 정보량이 적기 떄문에 파라미터에 대해 의존성이 적은 코드라 말할 수 있다.
>
> 파라미터가 너무 많은경우는 객체로 변경한다.
>
> -	개인적인 기준을 세우며 약 5개정도의 파라미터는 객체로 만드는 것이 좋아 보인다.

### 클래스의 스코프

> 클래스의 선언에서는 주료 public 을 사용하는 경우가 많으나, 프레임워크나 라이브러리를 작성하는 상황에서 package private 를 사용하는 경우가 종종 있다. 이는 라이브러리의 이용자에게 알리고 싶지 않은 클래스를 package private 로 함으로써 나중에 클래스를 변경할지라도 변경의 영향을 이용자에게 주지 않게 할 수 있기 때문이다.

###### - 내부 클래스

> 내부 클래스 (inner class) 란 클래스 내에 정의된 클래스이다.

###### - 무명 클래스

> 무명 클래스 (nameless class) 란 그자리에서 클래스 정의를 작성하여 이용하는 클래스명이 없는 클래스이다. 익명 클래스라고도 불린다.
>
> 한 곳에서밖에 사용되지 않으며, 나중에 재 이용할 일 없는 클래스로 private 보다 작은 스코프가 된다.

### 캐스트를 사용한 가시성의 제어

> 객체를 추상적인 형태로 캐스트(형 변환) 함으로써 객체에서 사용할 수 있는 메소드를 줄일 수 있다.
>
> ```java
> // 변수가 구체적인 클래스
> ArrayListItem items = new ArrayListItem();
> items.ensureCapacity(100); // ArrayList 메소드 호출
> ```
>
> ```java
> // 변수가 인터페이스인 경우
> ListItem items = new ArrayListItem();
> items.ensureCapacity(100); // 컴파일 에러
> ```
>
> 언뜻보면 변수가 구체적인 클래스가 많은 메소드를 호출할 수 있어 편리한 생각도 들지만 불필요한 메소드는 안 보이게 하는 편이 좋다. 인터페이스와 같은 추상적인 형태로 캐스트함으로써 사용 가능한 메소드들을 걸러 내어 불필요한 메소드를 숨길 수 있다. 이로 인해, 가시성을 낮게 하는 동시에 기존의 코드를 변경하는 일 없이 같은 인터페이스나 부모 클래스로부터 파생한 다른 형태의 객체로 변경할 수 있게 된다.

### 보다 큰 영역의 스코프

> 변수나 메소드, 클래스 등의 스코프는 작은 영역의 스코프다. 보다 큰 영역의 스코프로서는 디자인 패턴등의 컴포넌트 레벨부터 시스템 전체의 아키텍처 레벨까지 여러 가지 영역의 것들이 있다.
>
> 기본은 **'스코프 = 볼 수 있는 범위 = 사용할 수 있는 범위 = 의존하는 범위 = 유지보수성에 영향을 주는 범위'** 가 된다.

### 정리

> *['스코프 = 볼 수 있는 범위 = 사용할 수 있는 범위 = 의존하는 범위 = 유지보수성에 영향을 주는 범위'] 를 프로그래밍할때 항상 생각하며 프로그래밍을 해야 겠다.. 스코프가 크다면 느껴지면 다시한번 생각해 보자.!*
